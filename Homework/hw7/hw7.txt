1, 
First Program:
char a="abcdefg";
It assigns a string to a character, which does not make sense. 
a[7]='3';
a[8]='3';
a[9]='3';
These lines do not make sense since a is not an array or pointer. Eg, we cannot assign '3' to 7 units after a that is not a starting address. 


Second Program:
Here is the assembly code generated by GDB:
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400572 in main ()
(gdb) disas
Dump of assembler code for function main:
   0x000000000040053d <+0>:	push   %rbp
   0x000000000040053e <+1>:	mov    %rsp,%rbp
   0x0000000000400541 <+4>:	sub    $0x20,%rsp
   0x0000000000400545 <+8>:	movq   $0x400654,-0x8(%rbp)
   0x000000000040054d <+16>:	movl   $0x1,-0x14(%rbp)            // declare i=1 located at -0x14(%rbp)
   0x0000000000400554 <+23>:	lea    -0x14(%rbp),%rax
   0x0000000000400558 <+27>:	mov    %rax,-0x10(%rbp)            // save addresses
   0x000000000040055c <+31>:	mov    -0x10(%rbp),%rax
   0x0000000000400560 <+35>:	add    $0x4,%rax
   0x0000000000400564 <+39>:	movl   $0x7,(%rax)                 // assign p[1] = 7
   0x000000000040056a <+45>:	mov    -0x8(%rbp),%rax             // moving content of -0x8(%rbp) to %rax
   0x000000000040056e <+49>:	add    $0x7,%rax                   // adding content of %rax by 7
=> 0x0000000000400572 <+53>:	movb   $0x33,(%rax)
   0x0000000000400575 <+56>:	mov    -0x8(%rbp),%rax
   0x0000000000400579 <+60>:	add    $0x8,%rax
   0x000000000040057d <+64>:	movb   $0x33,(%rax)
   0x0000000000400580 <+67>:	mov    -0x8(%rbp),%rax
   0x0000000000400584 <+71>:	add    $0x9,%rax
   0x0000000000400588 <+75>:	movb   $0x33,(%rax)
   0x000000000040058b <+78>:	mov    -0x14(%rbp),%eax
   0x000000000040058e <+81>:	add    $0x1,%eax
   0x0000000000400591 <+84>:	mov    %eax,-0x14(%rbp)
   0x0000000000400594 <+87>:	mov    0x200a9e(%rip),%eax        # 0x601038 <j>
   0x000000000040059a <+93>:	add    $0x1,%eax
   0x000000000040059d <+96>:	mov    %eax,0x200a95(%rip)        # 0x601038 <j>
   0x00000000004005a3 <+102>:	mov    0x200a8f(%rip),%ecx        # 0x601038 <j>
   0x00000000004005a9 <+108>:	mov    -0x14(%rbp),%edx
   0x00000000004005ac <+111>:	mov    -0x8(%rbp),%rax
   0x00000000004005b0 <+115>:	mov    %rax,%rsi
   0x00000000004005b3 <+118>:	mov    $0x40065c,%edi
   0x00000000004005b8 <+123>:	mov    $0x0,%eax
   0x00000000004005bd <+128>:	callq  0x400420 <printf@plt>
   0x00000000004005c2 <+133>:	mov    $0x0,%eax
   0x00000000004005c7 <+138>:	leaveq 
   0x00000000004005c8 <+139>:	retq   
End of assembler dump.

We get segmentation fault up to the point 0x0000000000400572 <+53>. According to the notes given above in the assembly code, %rax accepts the contents at -0x8(%rbp), which is actually the string assigned at the beginning. Adding 7 to it does not give a right address, so {movb   $0x33,(%rax)} must be a segmentation fault. 


Third Program:
Using GDB and observing the stack through the course of the program, I extracted two important statuses of the stack shown below. 
(gdb) x/20wx $rsp
0x7fffffffe220:	0x004005c0	0x00000000	0x00400450	0x00000001
0x7fffffffe230:	0x64636261	0x00676665	0xffffe22c	0x00007fff
0x7fffffffe240:	0x00000000	0x00000000	0xf7a55b25	0x00007fff
0x7fffffffe250:	0x00000000	0x00000000	0xffffe328	0x00007fff
0x7fffffffe260:	0x00000000	0x00000001	0x0040053d	0x00000000
(gdb) ni
0x000000000040056a in main ()
(gdb) ni
0x0000000000400570 in main ()
(gdb) x/20wx $rsp
0x7fffffffe220:	0x004005c0	0x00000000	0x00400450	0x00000001
0x7fffffffe230:	0x00000007	0x00676665	0xffffe22c	0x00007fff
0x7fffffffe240:	0x00000000	0x00000000	0xf7a55b25	0x00007fff
0x7fffffffe250:	0x00000000	0x00000000	0xffffe328	0x00007fff
0x7fffffffe260:	0x00000000	0x00000001	0x0040053d	0x00000000

The first part shows the stack when the string is pushed onto the stack. The second part represents after the operation p[1]=7 what the stack looks like. Assigning p[1]=7 wipes out some parts of the string, so when the print function is called, it would not be able to locate a proper string. That's why a is not printed out. 


2,
Request  Block size (decimal bytes)  Block header (hex)

malloc(3)        8                      0x00000009
malloc(11)      16                      0x00000011
malloc(20)      24                      0x00000019
malloc(21)      32                      0x00000021

Eg. the first one. 3+4=7, rounded up to 8. allocated, so a =1, then header is 0x00000009.


3,
/* We need a global variable declared as: */
static char *count;    
/* the function */
static void *find_fit(size_t asize){
    char *newcount = count;

    for ( ; GET_SIZE(HDRP(count)) > 0; rover = NEXT_BLKP(count))
	if (!GET_ALLOC(HDRP(count)) && (asize <= GET_SIZE(HDRP(count))))
	    return count;

    for (count = heap_listp; count < newcount; count = NEXT_BLKP(count))
	if (!GET_ALLOC(HDRP(count)) && (asize <= GET_SIZE(HDRP(count))))
	    return count;

    return NULL;  /* no fit */
}